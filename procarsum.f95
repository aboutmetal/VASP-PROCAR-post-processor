program procar_sum
implicit none

! Completed  on April 13 2015
!**************************************************************************************************
!  Post processor for PROCAR files generated by VASP
!               looks at the  each band in PROCAR
!               sums the contribution over specified k-point range for each Y_lm
!               Can handle PROCARS from lda/gga, lsda/gsga, and Spin-Orbit coupling calculation
!    PROCAR file given by standard input, output to standard output   
!**************************************************************************************************
integer :: i
character(len=32),dimension(4) :: arg

do i = 1,4
    CALL get_command_argument(i,arg(i))
    if ((len_trim(arg(i)) .eq.0) .or. (arg(i) .eq. "--help")) then
      print*," usage: ./procarsum4.0.f {--lda|lsda|soc} lower_k upper_k filename(=generally PROCAR)"
      CALL EXIT(0)
    end if
end do

  call mode1(arg(1),arg(2),arg(3),arg(4))

END

SUBROUTINE mode1(option,lower_k_str,upper_k_str,filename)
    character(len=32),INTENT(IN) :: filename,lower_k_str,upper_k_str,option 
    ! summing over k-points between lower_k and upper_k
    integer :: lower_k,upper_k
    ! flag is designed to be 1 for lda, 2 for lsda. soc_index is 4 for SOC, 1 for others dummy1= ion number
    ! row index holds the rows, necessary in case soc is selected
    integer :: i,j,k,l,spin_index
    ! band index variable. nbands=no. of bands. nions = no. of ions. norbits = number of rows in a block
    integer :: nk,nband,nion,norbit
    !String  targets the header (which looks like 'k-point xxxx' or 'band xxxx') of each k-point block in PROCAR
    ! s is for strings that only need to be read so as to skip over them.
    character(100) :: string,num_string,s
    ! header reads the header string (ion     s    p...) of each block
    character(100) :: header
    ! used to read num_string as an integer
    integer :: num
    ! holds the first column (ions  1 2 3 ...tot ...)
    character(len=3),allocatable :: ion(:)
    ! occ holds the occupancy for each band in each k in the target range
    ! occ_avg holds the average occupancy in the target range for each band
    ! first index is spin index which can be wither 1 or 2
    real,dimension(:,:),allocatable :: occ,occ_avg
    !band_matrix array reads in the PROCAR block for a specific k-point and band (corresponding sel_band)
    !band_matrix(no_of_ions,no_of_orbits)
    real,allocatable :: band_matrix(:,:)
    ! each band_sum sums the corresponding matrix band over all k-points
    ! band_sum(ispin state, no. of bands, no. of ions, no. of orbits)
    real,allocatable :: band_sum(:,:,:,:)
    integer :: dummy1=0

    !*********************************************************************************************************
    !open(1,status='old',file='PROCAR') file opened to read parameters, so matrices can be allocated
    open(1,status='old',file=filename)
    ! In the following loop, nk,nband,nion,norbit are foubnd out
       read(1,*)string      ! reads the "PROCAR ..." title
       if (string .ne. "PROCAR") then
         write(0,*),"error:Are you sure your input file is PROCAR? file doesn't start with PROCAR..."
       end if
       read(1,*)string,string,string,nk,string,string,string,nband,string,string,string,nion ! parameter line
       if (index(string,"ions").eq.0) then
         print*,"error:Not sure this is PROCAR. the last parameter should say ions, says: ",string 
       else 
         write(*,*)"# of k-points:",nk,"# of bands:",nband,"# of ions:",nion
       end if
       read(1,*) string      ! k-point    XXXX :... line
       read(1,*) string      ! band  XXX line
       read(1,*)
       read(1,'(A)') header   ! reads the ' ions     s     py..." header
       norbit = ((len_trim(header)) - 10 )/7   ! the header length format is 5 + 7*x +5
       if ((norbit.ne.1).and.(norbit.ne.4) .and. (norbit.ne.9) .and. (norbit.ne.16)) then
         print*, " error:The number of orbits seem odd. should be 1/4/9/16, is: ", norbit
       end if  
    close(1)
    !*********************************************************************************************************

    !*********************************************************************************************************
    read(lower_k_str,*)lower_k
    read(upper_k_str,*),upper_k
    !Parameters used to allocate arrays depending on the type of PROCAR
    if (trim(option) .eq. "--lda") then
      nion = nion + 1  ! So I can use the same variable to include the "tot ..." row
      spin_index = 1   ! no spin state
    else if (trim(option).eq. "--lsda") then
      nion =  nion + 1  ! So I can use the same variable to include the "tot ..." row
      spin_index = 2   ! two spin states
    else if (trim(option).eq. "--soc") then
      nion = (nion + 1)*4        ! To account for 4 blocks (tot, mx,my,mz)
      spin_index = 1   ! no spin state  
    else
      print*,"invalid option",option
      CALL EXIT(0)
    end if
      allocate(band_matrix(nion,norbit+1))  ! rows are also 1 value longer because of the "tot" term
      allocate(band_sum(spin_index,nband,nion,norbit+1))
      allocate(ion(nion))
      allocate(occ(spin_index,nband))
      allocate(occ_avg(spin_index,nband))
    !**********************************************************************************************************
    band_matrix = 0.0
    band_sum = 0.0
    num = 0
    spin_index = 0    
    occ = 0.0
    occ_avg = 0.0
    !**********************************************************************************************************
    ! Summing starts
    open(1,status='old',file=filename)    ! File opened to read and sum
    do
        read(1,*,END = 10)string,num_string   
        if (index(string,"#") .gt. 0) then  ! "#" is the starting integer twice if there is spin, once if not.
          spin_index = spin_index + 1
        end if
        if (string=='k-point') then 
            read(num_string,*)num
            if(num.ge.lower_k.and.num.le.upper_k) then ! Enter a k-point bloc within k-point range 
                do k = 1,nband
                    read(1,*) string,num,s,s,s,s,s,occ(spin_index,k) ! Enters the subspace of bands for each k-point
                    read(1,*)
                    read(1,'(A)')string
                    if (string .ne. header) then
                      print*,"error:check file format; block header not consistent"
                      print*," error:first header:",header
                      print*,"header for band",num,"=",string
                      call EXIT(0)
                    end if
                    do i = 1,nion ! read the array including the 'tot' line. 'nion' depends on 'option'
                        read(1,*)ion(i),(band_matrix(i,j),j=1,norbit+1)  
                    end do  
                    band_sum(spin_index,num,:,:) = band_sum(spin_index,num,:,:) + band_matrix(:,:)    
                    band_matrix = 0.0 
                end do
                occ_avg = occ_avg + occ
                occ = 0.0
             else
             end if
         else
         end if 
    end do
    close(1) 

    10 CONTINUE

    band_sum = band_sum/(1+upper_k-lower_k)   ! Normalization
    occ_avg = occ_avg/(1+upper_k-lower_k)     ! averaging of occupancies
    write(*,*)"#calculations type:",option
    write(*,*)"#k-point",lower_k,"through",upper_k
    do l = 1,spin_index
      if (spin_index == 2) then
        write(*,*)"#spin channel = ",l
      end if
        write(*,*)"    "
        write(*,*)"    "
      do i = 1,nband
        write(*,"(A8,I5,A22,F8.6)")"band =",i,"  average occupancy = ",occ_avg(l,i)
        write(*,*),"    "
        write(*,*)header
        do j = 1,nion
          write(*,"(A5,100F7.3)")ion(j),(band_sum(l,i,j,k),k = 1,norbit+1)
        end do
        write(*,*),"    "
        write(*,*),"    "
      end do
    end do
    
    deallocate(band_matrix)
    deallocate(band_sum)
    deallocate(ion)
    deallocate(occ)
    deallocate(occ_avg)
    RETURN
END


